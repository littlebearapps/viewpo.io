---
import type { RoadmapColumn } from '@/lib/roadmap/types';
import RoadmapCard from './RoadmapCard.astro';
import RoadmapDrawer from './RoadmapDrawer.astro';

interface Props {
  columns: RoadmapColumn[];
}

const { columns } = Astro.props;

// Collect unique label names across all items for filter buttons
const allLabels = new Set<string>();
for (const col of columns) {
  for (const item of col.items) {
    for (const label of item.labels) {
      allLabels.add(label.name);
    }
  }
}
const filterLabels = Array.from(allLabels).sort();

// Column caps — how many to show initially before "Show more"
const COLUMN_CAPS: Record<string, number> = {
  'in-progress': 20, // No cap needed (small column)
  planned: 10,
  shipped: 8,
};

const columnHeaders: Record<string, { icon: string; emptyText: string }> = {
  'in-progress': {
    icon: '<path stroke-linecap="round" stroke-linejoin="round" d="M11.42 15.17l-5.384-3.028A2.25 2.25 0 014.5 10.122V6.75a2.25 2.25 0 011.536-2.02l5.384-3.028a2.25 2.25 0 012.16 0l5.384 3.028A2.25 2.25 0 0119.5 6.75v3.372a2.25 2.25 0 01-1.536 2.02l-5.384 3.028a2.25 2.25 0 01-2.16 0z" />',
    emptyText: 'Nothing in progress',
  },
  planned: {
    icon: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />',
    emptyText: 'Nothing planned yet',
  },
  shipped: {
    icon: '<path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />',
    emptyText: 'Nothing shipped yet',
  },
};

const statusStyles: Record<string, { text: string; bg: string }> = {
  'in-progress': { text: 'text-secondary', bg: 'bg-secondary/10' },
  planned: { text: 'text-primary', bg: 'bg-primary/10' },
  shipped: { text: 'text-success', bg: 'bg-success/10' },
};

// Column display order: In Progress → Planned → Shipped
const COLUMN_ORDER = ['in-progress', 'planned', 'shipped'];
---

<div id="roadmap-grid">
  <!-- Search + Filter bar -->
  <div class="mb-8 space-y-3">
    <!-- Search -->
    <div class="relative max-w-sm mx-auto">
      <svg class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-foreground/30" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
      </svg>
      <input
        type="search"
        id="roadmap-search"
        placeholder="Search roadmap..."
        class="w-full pl-9 pr-4 py-2 text-sm border border-neutral-200 dark:border-neutral-700 rounded-xl bg-white dark:bg-neutral-900/60 text-foreground placeholder:text-foreground/40 focus:outline-none focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all"
        autocomplete="off"
      />
    </div>

    <!-- Filter buttons -->
    {filterLabels.length > 1 && (
      <div class="flex flex-wrap gap-2 justify-center" role="toolbar" aria-label="Filter roadmap items by category">
        <button
          type="button"
          class="filter-btn platform-option platform-option-active text-xs font-heading font-medium px-3 py-1.5 rounded-lg border transition-all"
          data-filter="all"
          aria-pressed="true"
        >
          All
        </button>
        {filterLabels.map((label) => (
          <button
            type="button"
            class="filter-btn platform-option text-xs font-heading font-medium px-3 py-1.5 rounded-lg border transition-all"
            data-filter={label}
            aria-pressed="false"
          >
            {label}
          </button>
        ))}
      </div>
    )}
  </div>

  <!-- Mobile tab bar -->
  <div class="flex md:hidden border-b border-neutral-200 dark:border-neutral-700 mb-6 -mx-1" role="tablist" aria-label="Roadmap sections">
    {COLUMN_ORDER.map((status, idx) => {
      const col = columns.find((c) => c.status === status);
      if (!col) return null;
      const style = statusStyles[status] ?? statusStyles.planned;
      return (
        <button
          type="button"
          role="tab"
          class={`mobile-tab flex-1 px-2 py-3 text-xs font-heading font-semibold text-center border-b-2 transition-colors ${idx === 0 ? 'border-current ' + style.text : 'border-transparent text-foreground/40 hover:text-foreground/60'}`}
          data-tab-status={status}
          aria-selected={idx === 0 ? 'true' : 'false'}
          aria-controls={`col-${status}`}
        >
          {col.name} <span class="text-foreground/30 font-normal">({col.items.length})</span>
        </button>
      );
    })}
  </div>

  <!-- Kanban columns — 3 columns on desktop -->
  <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
    {COLUMN_ORDER.map((status, colIdx) => {
      const col = columns.find((c) => c.status === status);
      if (!col) return null;

      const header = columnHeaders[status] ?? columnHeaders.planned;
      const style = statusStyles[status] ?? statusStyles.planned;
      const cap = COLUMN_CAPS[status] ?? 20;
      const visibleItems = col.items.slice(0, cap);
      const hiddenItems = col.items.slice(cap);

      return (
        <div
          class={`roadmap-column ${colIdx > 0 ? 'hidden md:block' : ''}`}
          data-status={status}
          id={`col-${status}`}
          role="tabpanel"
        >
          <!-- Column header -->
          <div class="flex items-center gap-2 mb-4">
            <div class={`w-8 h-8 rounded-lg ${style.bg} flex items-center justify-center`}>
              <svg class={`w-4 h-4 ${style.text}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                <Fragment set:html={header.icon} />
              </svg>
            </div>
            <h2 class="font-heading font-semibold text-sm text-foreground">{col.name}</h2>
            <span class="text-xs text-foreground/40 ml-auto column-count">{col.items.length}</span>
          </div>

          <!-- Cards -->
          <div class="space-y-2">
            {visibleItems.length > 0 ? (
              visibleItems.map((item) => (
                <RoadmapCard {...item} />
              ))
            ) : (
              <div class="text-center py-8 px-4 rounded-xl border border-dashed border-neutral-200 dark:border-neutral-700">
                <svg class="w-8 h-8 text-foreground/20 mx-auto mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5m6 4.125l2.25 2.25m0 0l2.25 2.25M12 13.875l2.25-2.25M12 13.875l-2.25 2.25M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" />
                </svg>
                <p class="text-sm text-foreground/40">{header.emptyText}</p>
              </div>
            )}

            <!-- Hidden overflow items -->
            {hiddenItems.length > 0 && (
              <div class="overflow-cards hidden" data-overflow-status={status}>
                {hiddenItems.map((item) => (
                  <div class="mb-2">
                    <RoadmapCard {...item} />
                  </div>
                ))}
              </div>
            )}

            {/* Show more button */}
            {hiddenItems.length > 0 && (
              <button
                type="button"
                class="show-more-btn w-full py-2.5 text-xs font-heading font-medium text-foreground/50 hover:text-primary border border-dashed border-neutral-200 dark:border-neutral-700 hover:border-primary/30 rounded-xl transition-all"
                data-show-more={status}
              >
                Show {hiddenItems.length} more {status === 'shipped' ? 'shipped items' : 'items'}
              </button>
            )}
          </div>
        </div>
      );
    })}
  </div>
</div>

<!-- Drawer (rendered once, populated dynamically) -->
<RoadmapDrawer />

<script>
  function initRoadmapGrid() {
    const grid = document.getElementById('roadmap-grid');
    if (!grid) return;

    // --- Card click → open drawer ---
    grid.addEventListener('click', (e) => {
      const card = (e.target as HTMLElement).closest<HTMLElement>('[data-roadmap-card]');
      if (!card) return;

      // Don't open drawer if clicking the vote button
      if ((e.target as HTMLElement).closest('[data-vote-btn]')) return;

      const json = card.dataset.itemJson;
      if (!json || !window.__roadmapDrawer) return;

      try {
        const itemData = JSON.parse(json);
        window.__roadmapDrawer.open(itemData);
      } catch {
        // Invalid JSON — ignore
      }
    });

    // Keyboard support for cards
    grid.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter' && e.key !== ' ') return;
      const card = (e.target as HTMLElement).closest<HTMLElement>('[data-roadmap-card]');
      if (!card) return;
      e.preventDefault();
      card.click();
    });

    // --- Search logic ---
    const searchInput = grid.querySelector<HTMLInputElement>('#roadmap-search');
    const allCards = grid.querySelectorAll<HTMLElement>('[data-roadmap-card]');

    if (searchInput) {
      searchInput.addEventListener('input', () => {
        const query = searchInput.value.toLowerCase().trim();

        allCards.forEach((card) => {
          if (!query) {
            card.style.display = '';
            return;
          }
          const title = card.querySelector('h3')?.textContent?.toLowerCase() ?? '';
          const labels = (card.dataset.labels ?? '').toLowerCase();
          card.style.display = (title.includes(query) || labels.includes(query)) ? '' : 'none';
        });

        updateColumnCounts();
      });
    }

    // --- Filter logic ---
    const filterBtns = grid.querySelectorAll<HTMLButtonElement>('.filter-btn');

    filterBtns.forEach((btn) => {
      btn.addEventListener('click', () => {
        const filter = btn.dataset.filter;

        // Update button states
        filterBtns.forEach((b) => {
          const isActive = b === btn;
          b.classList.toggle('platform-option-active', isActive);
          b.setAttribute('aria-pressed', String(isActive));
        });

        // Show/hide cards
        allCards.forEach((card) => {
          if (filter === 'all') {
            card.style.display = '';
          } else {
            const cardLabels = (card.dataset.labels ?? '').split(',');
            card.style.display = cardLabels.includes(filter!) ? '' : 'none';
          }
        });

        // Clear search when filter changes
        if (searchInput) searchInput.value = '';

        updateColumnCounts();
      });
    });

    function updateColumnCounts() {
      grid.querySelectorAll<HTMLElement>('.roadmap-column').forEach((col) => {
        const visibleCards = col.querySelectorAll<HTMLElement>('[data-roadmap-card]:not([style*="display: none"])');
        const countEl = col.querySelector<HTMLElement>('.column-count');
        if (countEl) countEl.textContent = String(visibleCards.length);
      });
    }

    // --- Show more logic ---
    grid.querySelectorAll<HTMLButtonElement>('.show-more-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        const status = btn.dataset.showMore;
        if (!status) return;
        const overflow = grid.querySelector<HTMLElement>(`[data-overflow-status="${status}"]`);
        if (overflow) {
          overflow.classList.remove('hidden');
          btn.remove();
          updateColumnCounts();
        }
      });
    });

    // --- Mobile tab logic ---
    const tabs = grid.querySelectorAll<HTMLButtonElement>('.mobile-tab');
    const columnPanels = grid.querySelectorAll<HTMLElement>('.roadmap-column');

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        const targetStatus = tab.dataset.tabStatus;

        // Update tab states
        tabs.forEach((t) => {
          const isActive = t === tab;
          t.setAttribute('aria-selected', String(isActive));
          t.classList.toggle('border-transparent', !isActive);
          t.classList.toggle('text-foreground/40', !isActive);

          // Apply status colour to active tab
          if (isActive) {
            const style = {
              'in-progress': 'text-secondary',
              planned: 'text-primary',
              shipped: 'text-success',
            }[targetStatus!] ?? 'text-primary';
            // Remove all status colours first
            t.classList.remove('text-secondary', 'text-primary', 'text-success');
            t.classList.add(style);
            t.classList.add('border-current');
          } else {
            t.classList.remove('text-secondary', 'text-primary', 'text-success', 'border-current');
          }
        });

        // Show/hide columns (mobile only — md:block overrides)
        columnPanels.forEach((panel) => {
          const panelStatus = panel.dataset.status;
          if (panelStatus === targetStatus) {
            panel.classList.remove('hidden');
          } else {
            panel.classList.add('hidden');
            panel.classList.add('md:block');
          }
        });
      });
    });

    // --- Vote logic ---
    const VOTED_KEY = 'viewpo-roadmap-votes';

    function getVotedItems(): Set<string> {
      try {
        const stored = localStorage.getItem(VOTED_KEY);
        return stored ? new Set(JSON.parse(stored)) : new Set();
      } catch {
        return new Set();
      }
    }

    function saveVotedItems(items: Set<string>) {
      try {
        localStorage.setItem(VOTED_KEY, JSON.stringify(Array.from(items)));
      } catch {
        // localStorage unavailable
      }
    }

    const votedItems = getVotedItems();

    // Mark previously voted buttons
    grid.querySelectorAll<HTMLButtonElement>('[data-vote-btn]').forEach((btn) => {
      const itemId = btn.dataset.itemId;
      if (itemId && votedItems.has(itemId)) {
        markAsVoted(btn);
      }
    });

    function markAsVoted(btn: HTMLButtonElement) {
      btn.classList.remove('border-neutral-200', 'dark:border-neutral-600', 'text-foreground/60', 'hover:border-primary', 'hover:text-primary');
      btn.classList.add('bg-primary/10', 'border-primary/30', 'text-primary');
      btn.setAttribute('aria-pressed', 'true');
    }

    function markAsUnvoted(btn: HTMLButtonElement) {
      btn.classList.add('border-neutral-200', 'dark:border-neutral-600', 'text-foreground/60', 'hover:border-primary', 'hover:text-primary');
      btn.classList.remove('bg-primary/10', 'border-primary/30', 'text-primary');
      btn.setAttribute('aria-pressed', 'false');
    }

    // Vote click handler
    grid.addEventListener('click', async (e) => {
      const btn = (e.target as HTMLElement).closest<HTMLButtonElement>('[data-vote-btn]');
      if (!btn) return;

      const itemId = btn.dataset.itemId;
      if (!itemId) return;

      const countEl = btn.querySelector<HTMLElement>('.vote-count');
      if (!countEl) return;

      const currentCount = parseInt(countEl.textContent ?? '0', 10);

      // Already voted (from localStorage hint) — do nothing
      if (votedItems.has(itemId)) return;

      // Optimistic update
      countEl.textContent = String(currentCount + 1);
      markAsVoted(btn);
      votedItems.add(itemId);
      saveVotedItems(votedItems);

      try {
        const res = await fetch('/api/vote/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ itemId }),
        });
        const data = await res.json() as { votes?: number; alreadyVoted?: boolean; error?: string };

        if (!res.ok || data.error) {
          // Server error — revert optimistic update
          countEl.textContent = String(currentCount);
          markAsUnvoted(btn);
          votedItems.delete(itemId);
          saveVotedItems(votedItems);
          return;
        }

        // Update with server count
        countEl.textContent = String(data.votes ?? currentCount + 1);

        if (data.alreadyVoted) {
          // Already voted server-side — keep voted state but use server count
          votedItems.add(itemId);
          saveVotedItems(votedItems);
        }
      } catch {
        // Revert optimistic update on network error
        countEl.textContent = String(currentCount);
        markAsUnvoted(btn);
        votedItems.delete(itemId);
        saveVotedItems(votedItems);
      }
    });
  }

  initRoadmapGrid();
  document.addEventListener('astro:after-swap', initRoadmapGrid);
</script>
