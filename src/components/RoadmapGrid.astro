---
import type { RoadmapColumn } from '@/lib/roadmap/types';
import RoadmapCard from './RoadmapCard.astro';

interface Props {
  columns: RoadmapColumn[];
}

const { columns } = Astro.props;

// Collect unique label names across all items for filter buttons
const allLabels = new Set<string>();
for (const col of columns) {
  for (const item of col.items) {
    for (const label of item.labels) {
      allLabels.add(label.name);
    }
  }
}
const filterLabels = Array.from(allLabels).sort();

const columnHeaders: Record<string, { icon: string; emptyText: string }> = {
  planned: {
    icon: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />',
    emptyText: 'Nothing planned yet',
  },
  'in-progress': {
    icon: '<path stroke-linecap="round" stroke-linejoin="round" d="M11.42 15.17l-5.384-3.028A2.25 2.25 0 014.5 10.122V6.75a2.25 2.25 0 011.536-2.02l5.384-3.028a2.25 2.25 0 012.16 0l5.384 3.028A2.25 2.25 0 0119.5 6.75v3.372a2.25 2.25 0 01-1.536 2.02l-5.384 3.028a2.25 2.25 0 01-2.16 0z" />',
    emptyText: 'Nothing in progress',
  },
  testing: {
    icon: '<path stroke-linecap="round" stroke-linejoin="round" d="M9.75 3.104v5.714a2.25 2.25 0 01-.659 1.591L5.25 14.25 M9.75 3.104c-.251.023-.501.05-.75.082m.75-.082a24.301 24.301 0 014.5 0m0 0v5.714a2.25 2.25 0 00.659 1.591l3.841 3.841M14.25 3.104c.251.023.501.05.75.082M19.5 14.25l-2.341-2.341" />',
    emptyText: 'Nothing in testing',
  },
  shipped: {
    icon: '<path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />',
    emptyText: 'Nothing shipped yet',
  },
};

const statusStyles: Record<string, { text: string; bg: string }> = {
  planned: { text: 'text-primary', bg: 'bg-primary/10' },
  'in-progress': { text: 'text-secondary', bg: 'bg-secondary/10' },
  testing: { text: 'text-slate-500 dark:text-slate-400', bg: 'bg-slate-400/10' },
  shipped: { text: 'text-success', bg: 'bg-success/10' },
};
---

<div id="roadmap-grid">
  <!-- Filter buttons -->
  {filterLabels.length > 1 && (
    <div class="flex flex-wrap gap-2 mb-8 justify-center" role="toolbar" aria-label="Filter roadmap items by category">
      <button
        type="button"
        class="filter-btn platform-option platform-option-active text-xs font-heading font-medium px-3 py-1.5 rounded-lg border transition-all"
        data-filter="all"
        aria-pressed="true"
      >
        All
      </button>
      {filterLabels.map((label) => (
        <button
          type="button"
          class="filter-btn platform-option text-xs font-heading font-medium px-3 py-1.5 rounded-lg border transition-all"
          data-filter={label}
          aria-pressed="false"
        >
          {label}
        </button>
      ))}
    </div>
  )}

  <!-- Kanban columns -->
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
    {columns.map((col) => {
      const header = columnHeaders[col.status] ?? columnHeaders.planned;
      const style = statusStyles[col.status] ?? statusStyles.planned;

      return (
        <div class="roadmap-column" data-status={col.status}>
          <!-- Column header -->
          <div class="flex items-center gap-2 mb-4">
            <div class={`w-8 h-8 rounded-lg ${style.bg} flex items-center justify-center`}>
              <svg class={`w-4 h-4 ${style.text}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                <Fragment set:html={header.icon} />
              </svg>
            </div>
            <h2 class="font-heading font-semibold text-sm text-foreground">{col.name}</h2>
            <span class="text-xs text-foreground/40 ml-auto">{col.items.length}</span>
          </div>

          <!-- Cards -->
          <div class="space-y-3">
            {col.items.length > 0 ? (
              col.items.map((item) => (
                <RoadmapCard {...item} />
              ))
            ) : (
              <div class="text-center py-8 px-4 rounded-xl border border-dashed border-slate-200 dark:border-slate-700">
                <svg class="w-8 h-8 text-foreground/20 mx-auto mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5m6 4.125l2.25 2.25m0 0l2.25 2.25M12 13.875l2.25-2.25M12 13.875l-2.25 2.25M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" />
                </svg>
                <p class="text-sm text-foreground/40">{header.emptyText}</p>
              </div>
            )}
          </div>
        </div>
      );
    })}
  </div>
</div>

<script>
  function initRoadmapGrid() {
    const grid = document.getElementById('roadmap-grid');
    if (!grid) return;

    // --- Filter logic ---
    const filterBtns = grid.querySelectorAll<HTMLButtonElement>('.filter-btn');
    const allCards = grid.querySelectorAll<HTMLElement>('[data-labels]');

    filterBtns.forEach((btn) => {
      btn.addEventListener('click', () => {
        const filter = btn.dataset.filter;

        // Update button states
        filterBtns.forEach((b) => {
          const isActive = b === btn;
          b.classList.toggle('platform-option-active', isActive);
          b.setAttribute('aria-pressed', String(isActive));
        });

        // Show/hide cards
        allCards.forEach((card) => {
          if (filter === 'all') {
            card.style.display = '';
          } else {
            const cardLabels = (card.dataset.labels ?? '').split(',');
            card.style.display = cardLabels.includes(filter!) ? '' : 'none';
          }
        });

        // Update column counts
        grid.querySelectorAll<HTMLElement>('.roadmap-column').forEach((col) => {
          const visibleCards = col.querySelectorAll<HTMLElement>('[data-labels]:not([style*="display: none"])');
          const countEl = col.querySelector<HTMLElement>('.font-heading + span');
          if (countEl) countEl.textContent = String(visibleCards.length);
        });
      });
    });

    // --- Vote logic ---
    const VOTED_KEY = 'viewpo-roadmap-votes';

    function getVotedItems(): Set<string> {
      try {
        const stored = localStorage.getItem(VOTED_KEY);
        return stored ? new Set(JSON.parse(stored)) : new Set();
      } catch {
        return new Set();
      }
    }

    function saveVotedItems(items: Set<string>) {
      try {
        localStorage.setItem(VOTED_KEY, JSON.stringify(Array.from(items)));
      } catch {
        // localStorage unavailable
      }
    }

    const votedItems = getVotedItems();

    // Mark previously voted buttons
    grid.querySelectorAll<HTMLButtonElement>('[data-vote-btn]').forEach((btn) => {
      const itemId = btn.dataset.itemId;
      if (itemId && votedItems.has(itemId)) {
        markAsVoted(btn);
      }
    });

    function markAsVoted(btn: HTMLButtonElement) {
      btn.classList.remove('border-slate-200', 'dark:border-slate-600', 'text-foreground/60', 'hover:border-primary', 'hover:text-primary');
      btn.classList.add('bg-primary/10', 'border-primary/30', 'text-primary');
      btn.setAttribute('aria-pressed', 'true');
    }

    function markAsUnvoted(btn: HTMLButtonElement) {
      btn.classList.add('border-slate-200', 'dark:border-slate-600', 'text-foreground/60', 'hover:border-primary', 'hover:text-primary');
      btn.classList.remove('bg-primary/10', 'border-primary/30', 'text-primary');
      btn.setAttribute('aria-pressed', 'false');
    }

    // Vote click handler
    grid.addEventListener('click', async (e) => {
      const btn = (e.target as HTMLElement).closest<HTMLButtonElement>('[data-vote-btn]');
      if (!btn) return;

      const itemId = btn.dataset.itemId;
      if (!itemId) return;

      const countEl = btn.querySelector<HTMLElement>('.vote-count');
      if (!countEl) return;

      const currentCount = parseInt(countEl.textContent ?? '0', 10);

      // Already voted (from localStorage hint) — do nothing
      if (votedItems.has(itemId)) return;

      // Optimistic update
      countEl.textContent = String(currentCount + 1);
      markAsVoted(btn);
      votedItems.add(itemId);
      saveVotedItems(votedItems);

      try {
        const res = await fetch('/api/vote/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ itemId }),
        });
        const data = await res.json() as { votes: number; alreadyVoted: boolean };

        // Update with server count
        countEl.textContent = String(data.votes);

        if (data.alreadyVoted) {
          // Already voted server-side — keep voted state but use server count
          votedItems.add(itemId);
          saveVotedItems(votedItems);
        }
      } catch {
        // Revert optimistic update on network error
        countEl.textContent = String(currentCount);
        markAsUnvoted(btn);
        votedItems.delete(itemId);
        saveVotedItems(votedItems);
      }
    });
  }

  initRoadmapGrid();
  document.addEventListener('astro:after-swap', initRoadmapGrid);
</script>
